## GameOn! - Saved Games In-Depth (Part 2)

![video_screenshot](images/naQhSkzNGAI.jpg)

** 视频发布时间**
 
> 2014年9月17日

** 视频介绍**

> In this second part of our deep dive into Saved Games in the cloud and how they work, we look at conflicts between various saved games, how they happen, and how to resolve them. Trust us, you'll want to bookmark this and watch it later.

** 视频推介语 **

>  暂无，待补充。


### 译者信息

| 翻译 | 润稿 | 终审 | 原始链接 | 中文字幕 |  翻译流水号  |  加入字幕组  |
| -- | -- | -- | -- | -- |  -- | -- | -- |
| wang7x | 苏楚霖 | 程路 | [ Youtube ]( https://www.youtube.com/watch?v=naQhSkzNGAI )  |  [ Youtube ]( https://www.youtube.com/watch?v=EvolLUb_0cc ) | 1504030548 | [ 加入 GDG 字幕组 ]( http://www.gfansub.com/join_translator )  |



### 解说词中文版：

你好  欢迎回来

收看我们的下半部深入指南视频

学习如何用Google Play游戏服务来保存游戏存档

是的  你没听错

我说的是下半部

这是两集视频系列的第二部

如果你还没有看过上半部  赶紧找来看吧

否则 这部视频讲的东西就没什么用了

快去看吧

没关系

我会等你看完


准备好了吗

我们开始吧

现在我们进入超高的黑钻级难度学习

请带好你的护目镜

前路将会崎岖难行  不过我相信你能战胜它的

因为你筋骨奇佳  一定是个武学奇才

需要处理存档冲突

是非常少见的情况

但它确实有可能发生  尤其是一家人有多个设备时

当这种情况出现时 你需要

确保你的程序能正确处理

所以当你从云端读取一个存档时

存档会带有一个标识  你可以把这个标识

理解为版本号或者标签

这个标签标示了

云端服务器确认合法的最新版本的存档

我们称这个版本为基线版本

你不能够修改或者查看这个标签

它对你来说是隐藏的

但当你使用提交和关闭操作保存游戏存档到Google服务器

这个基线版本标签会与

新版本的存档一起发送到云端

云端服务器一旦接受到这个新存档

就会检查  上送的基线版本标签是否与

服务器记录的基线版本标签一致

如果一致  服务器就知道在你上一次读取存档

和现在提交存档之间  没有其他人上传过

不一致的存档

九成情况都会是这样

你的游戏存档将会被更新

并且服务器记录的基线版本标签会被更新

所以 正如我前面说过的

当你提交一个存档 它是关闭状态的

如果你需要对它做任何操作  必须重新打开它

当你重新打开这个

最新提交的存档时

就会从服务器上获取最新的基线版本标签

现在 让我们回到前面的例子

我将继续介绍因为添加另外一个设备

导致出现存档冲突的情况

这两个设备都打开了我的一个游戏存档

假设叫A版本存档 现在 在我的第一个设备

我做了一些操作

例如花费80金币买了一把宝剑

此时我们保存游戏存档到云端

Google服务器将检查跟存档一起发送的基线版本标签

并且确认了我发送的基线版本标签与

服务器记录的最新基线版本标签一致

此时一切正常

服务器就接受了这个新存档

给新存档分配一个标签B 如果我

在第一台设备上重新打开这个游戏存档

那么游戏将在存档B的基础上继续进行

但我们现在不这样做

相反  我们拿起第二台设备

还记得吗  这台设备上的游戏存档还是A版本的

好的 现在在这个存档基础上 我将花费金币

购买一个头盔而不是宝剑

然后 我把这个新的存档也保存到云端

服务器会发现这个存档是基于

A版本的，但是此时云端服务器上B版本存档才是最新的基线版本

此时冲突就出现了

不过服务器的处理可能不会跟你期望的一样

它不会拒绝这份存档

它只是记录一下出现了冲突的情况

然后保存这份最新的存档为

我们称之为A*版本好了  与B版本同时存在

为什么要这样处理呢

为什么服务器在你保存时

不直接拒绝发生冲突的存档

这样做是有原因的

其一是这种方法通常能更好的处理这样的场景

一个用户试图在设备未联网时

保存和读取游戏

另一个原因是Android设备

在应用程序运行时使用了一些巧妙的

网络请求缓存技术  可能没有立即保存你的

游戏存档到服务器

而是等到你的应用程序在后台运行时

才做保存存档到服务器的动作

如果你想要做一些类似询问用户以选择

正确存档的操作时

只能是应用程序处在前台运行时

通常也就是你重新

打开存档的时候

所以解决存档冲突的

关键时机是用户再次

打开最新存档

此时  服务器会说 噢 且慢

我有一份B版本的存档

它是合法的最新基线版本

但是还有一份A*版本

请问该如何处理

如果是你会怎样处理

你所做的处理操作会依赖于你的

开发平台和你的想法

在iOS平台中  你有许多选择  其中一个是

通过声明一个存档合并策略  让系统库

自动帮你解决冲突

如果你采用GPG存档策略BaseWins

实际上你是在告诉系统库

总是选择最新的基线版本存档

服务器会照做并且抛弃其他冲突的版本

在这种策略下  B版本存档会留下

如果你选择RemoteWins存档合并策略

则会选择冲突的那个版本

在我们的例子里即是A*版本

如果你问自己 等等 我二了吧

有什么可能我会选择冲突的版本

记住  至少在我们的例子中

A*版本存档实际上是最新保存的那个版本

所以这种策略也有意义

但恕我直说  这两种策略

区别不大并且效果一般

我认为更好的是LongestPlaytime存档合并策略

这个策略是指示系统库查看

两个版本存档的游戏时间数据

并选择你记录下的

用户玩的时间最长的那个版本

这是一种明智的解决冲突的方法

尤其是解决两个存档的冲突

其中一个存档是用户

在飞机上玩了4个小时才保存下来的

对不对

你肯定不想丢失这4个小时的进度

注意  无论如何  这种策略都依赖于

你  游戏开发者  记录的游戏时间数据

所以只有你记录准确时才更有效

最后  还有个GPG存档合并策略是Manual

这种策略下  你得到两个版本的存档

你打开和读取的全部权限  然后你可以

决定如何继续处理  既可以

选择两个版本中的一个

也可以创建一个全新的版本

某些情况下  如果你进行手工合并

尽管策略的名字可以手工合并  你也完全可以

使用你自己的游戏逻辑来合并

两个存档

这种策略在数据趋势比较单一 总是可以

简单的合二为一的游戏中最有效

嘿  让我们直接选择最高或者最低

的数字就好了

举一个例子  如果有一个游戏 假设是个解谜游戏

游戏存档中唯一需要记录的

是最高分数和每个关卡得到的星级

那么就可以自动的合并两个版本的存档

只是用一些简单的策略

例如固定选择每个关卡最高的分数作为结果

这样做合并会非常成功

但是在其他大多数的情况下  例如我们的例子

用户在一个存档中买了一个头盔 在另一个中

买了把宝剑  这种情况下我不确认是否能够自动的合并

除非有一种宝剑是

能够戴在头上的

虽然有看起来有点傻

所以这种情况的最佳方案是

弹出一个对话框 请用户

选择想要保留哪一个存档

记住  此时如果你需要的话  可以像访问真实的游戏数据

一样访问存档的数据

这样弹出的对话框

就可以带有一些能够让你的用户做出决定的信息

如果这么做了  当提交用户选择的版本时

它就会被保存到服务器上

服务器会把这个版本标记为C

然后把它置为关闭状态

这意味着  是的  你需要

重新打开一次这个存档才能继续

好了 我们来看看Android平台这边

你的选择会受一些限制

没有了花哨的自动合并策略

实际上你要做的就是从两个版本中选择一个

然后继续处理

为了辅助你完成这个操作  在代码中你可以请求同时获取

两个版本的存档

这段代码所指的存档就是

基线存档 在我们的例子中

叫做B版本存档

然后这段代码所指的冲突存档就是

我们例子中被成为A*版本的存档

现在你可以用简单的几行代码实现

iOS平台上的几种合并策略

例如  我们可以总是选择基线版本存档

也可以总是选择远端或者叫冲突版本存档

或者选择游戏时间最长的版本

如果你想要  嘿  弹出一个对话框给

用户  展示两个版本的存档并且让用户

选择继续哪一个版本的存档

这些也都可以做到

我只是没有列出这样例子的代码

唯一需要一些技巧的地方

当我们做了一个手工的合并  产生了一个

综合了两个版本内容的新存档时

记住在Android平台上  你一定要选择

两个版本中的一个才能够继续处理

所以我们需要选择这些存档中的一个

作为最新的存档

然后我们可以立即打开它

使用我们的自动合并机制

应用该存档所有的修改

然后再次保存并提交它

出于满足你的好奇心  其实这也是

iOS平台库在处理第三个存档时

在后台自动做的操作步骤

它代替你来做这些操作

是认为这样比较易用

在C++平台  你有另外两个平台功能的综合体

我们既可以让你从几个自动合并策略中选择

正如iOS平台上一样

如果你要手工处理两个版本存档的

冲突  并新增第三个版本

首先你需要选择其中一个版本  提交它

然后重新打开它  应用所有的修改

然后像在Android Java SDK上一样再次提交它

无论采取哪种方式  一旦你解决冲突并提交了

新版本的存档  你应当

充满信心的重新打开你的游戏存档  然后

发现世界又和平了

不是吗

好吧 类似吧

在某些极端情况下  你可能发现解决完冲突后

还有一个或者更多的冲突版本在服务器上

等着你处理

通常  这种情况发生是因为玩家在

三台或者更多的设备上运行游戏

这种情况肯定极罕见

但确实有可能发生

在这类情况下  当你请求打开一个存档时

你会得到一个基线版本和一个冲突版本去解决

就像之前一样

然后你同样发送了一个合并好的版本

到服务器  基线版本的标签也更新了

存档状态置为关闭

然后我们的游戏依然需要使用这个存档

所以它请求服务器打开它

此时服务器告诉我们  嘿  且慢

你还需要解决新基线版本存档与

另一个版本的冲突

但这难不倒我们

是吧

我们还是在解决两个版本的冲突

还是按照之前一样的程序逻辑

我们轻易的解决了这一对存档的冲突

提交正确的版本到云端服务器

服务器将新版本置为关闭  然后我们最后一次打开它

这下天下太平了

通常来说  这种一次只增加一个冲突版本的

的思想不会让你手忙脚乱

毕竟  我们实际上只是

运行了同一段逻辑许多次

我认为比较考验技巧的地方是

你作为一个Android  Java或者C++开发者

在现有存档的基础上  你的游戏正要应用你刚刚

合并完成并提交的存档

以为服务器在你上一次提交和这一次重新打开之间

只会返回一个存档

但是不幸的  你接到了两个  这可能会搞乱你的程序

此时你应该怎么做会依赖于

你的游戏的逻辑  你的存档的内容

和服务器上远程存档的内容

但是同样  这其实只是对你已有代码功能的

一点点延伸

你只需要留意可能会出现这样的情况

并且做一些防御性的编程即可

好了

讲了这么多零零碎碎的东西  我

希望当你为你的游戏实现存档功能时

能够对内部的机制有一些

更深入的理解

不必担心没有搞懂这一切

我们有简明的示例代码和指南供你查阅

当然  你可以随时重温这个视频

如果我是你  我会把这部视频加入收藏

当你开始动手时找出来

再看一遍  因为可能

有些例子能够帮上忙

再一次的  非常感谢你的收看

可以自行关注我的G+了解一些我工作相关的东西

还有Twitter上轻松愉快的东西

另外  我将会在不远的未来与你

在YouTube继续相见

再见  滑板小子

这年代人们还这么说吗

暴露年龄了

你知道吗

我们很快就会再见

拜