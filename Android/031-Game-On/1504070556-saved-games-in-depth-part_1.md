## GameOn! - Saved Games In-Depth (Part 1)

![video_screenshot](images/iHc2RBZs5T0.jpg)

** 视频发布时间**
 
> 2014年9月15日

** 视频介绍**

> Find out about the new-and-improved Saved Game in the cloud feature from Google Play Games, and how it all works under the hood!

** 视频推介语 **

>  暂无，待补充。


### 译者信息

| 翻译 | 润稿 | 终审 | 原始链接 | 中文字幕 |  翻译流水号  |  加入字幕组  |
| -- | -- | -- | -- | -- |  -- | -- | -- |
| brite | 素年待锦 | —— | [ Youtube ]( https://www.youtube.com/watch?v=iHc2RBZs5T0 )  |  [ Youtube ]( https://www.youtube.com/watch?v=BoSE50R-3HA ) | 1504070556 | [ 加入 GDG 字幕组 ]( {{ book.host }}/join_translator )  |



### 解说词中文版：

如果你没有把用户的游戏存在云端服务器


我恐怕  当他们换了新玩具后就会产生用户流失


这是因为  我相信 不管你设计的游戏有多棒 


都没人愿意重新安装一遍  再从新手开始


再玩一次


我是Todd Kerpelman  鉴于互联网上


已有众多云端存储方案  我这边要告诉你的是


如今你在Google Play上可以免费得到同样


游戏服务


负责游戏的团队已经更新了他们的旧版云端存储的


很多方面


呵  它的改动太大  我们甚至把名称都改了


现在 它唤做云游 不再叫做云存了


我们也为此设计了很多独特的图标


图标里面有个箭头  可代表的却是一切


别认为它只是换了一个新图标


它涵盖了很多东西


基于旧版云存的改进


最大变化之处是  你现在可以存储很大包的数据


最大可至3M


那可是老大一堆的数据呵


在以前  你会被限制在四位数字以内的


现在  你几乎可以为所欲为了


现在  游戏保存之后  在Play Store里你就会有一个云游牌


这样每个人都会知道自己能够


把正在消遣的游戏进度保存起来


你还可以在你存储的云游上添加媒体数据


像是 一个具体描述和载体图像


这些使得你的云游


在游戏程序或是你自己的游戏里有个很棒的展示


我说  瞅瞅这些漂亮的存储云游


难道你不想去点击一下他们吗


我知道我是忍不住


你知道  玩家一看到游戏程序中的这些东东


他们就想起来了  哦


我玩到这个级别了


我刚刚得到了这个酷爱的新宝剑


我可以从上次退出点继续玩下去


哦这些新功能太棒了  可是这些新花样也需要


游戏提供一种新的云游数据存储办法


和处理冲突的新途径


我常常发觉  处理这些数据


特别是它处于调试状态的时候 


最好要对它的原理有个深度的理解


而不是看外表的那些神秘的黑盒子


所以 让我们来看一看 荧幕之后的东东


你可能会学到一些东西


那么你要理解的第一件事


就是云游是在内部代表的是


一个对象 我们叫做快照


快照这个对象包含了元数据  包含的东西有Metadat  其中含有


文件的描述  封面图片  游戏时间


的长短  还有个当地时间印


当然还有一堆游戏数据


Saved Games 是由Google Drive提供


正当你把云游存储或上传


到云端服务器上  最好使用Google Drive 账户


来记录现在的状态


那里有个隐藏的文件夹


专为你的应用程序所建  快照就存在那里


这些快照就是存储在这个文件夹里面


你可以像往常一样给他们取名


也和其他普通文件一样  这些名字


是我们分清你的应用程序所需的这些快照的基本途径


然而  你的用户  却无法看到这些名字


他们可以看到这些快照的描述  封面图片


以及其他的元数据  但是这个名字


是从不与他们相关联的


这些名字  仅仅是为你的应用程序使用快照时的辨别使用的


现在你可以询问并测试任何


元数据  在你需要的任何时候


但是  有一件非常重要的事情  就是要了解清楚它是如何读取云游数据


或如何写入云游数据的  甚至如果你正在存入一个编号


新快照之前  你必须首先打开这个快照


重复一下  我猜它类似有些程序语言那样去操作


本地文件  如Python语言


你能够找到最后修改的文件


但当你想要读取或改写该文件时


你将需要将它调用出来  取得该文件的控制权限


现在的绝大多数情况  这个打开指令  这并不太令人激动


荧屏之后有什么事情发生呢


那就是你的设备正在下载该游戏的所有东东


即是与你快照相关的元数据


如果它没有去做这些事  然后会告诉你的游戏


何时它会做完


但是该指令不会变得复杂化


当我们处理冲突的时候  保持调整状态


现在记得以上规则后 让我们看一个简单情况


即当我打算调入一既有的云端游戏之时


做一些修改  然后再次存储


调入或打开云端游戏的动作就会开始启动


通过辨别快照的名称来打开它


现在  如果你正在处理一个单一的云端游戏


你将要去做存入和上载的动作


你可以能够成功地将这个文件编码


在某处把它作为一个常数来命名


记住  这些云端游戏会在用户的硬盘里存储起来


登录在一个专为你的游戏所保留的文件夹里


因此 你勿须担心 文件命名的唯一性是否有问题


你不必非得输入  com.example.myap p.savedGame.userId


你可以输入一些很稀疏平常的词


就像  SavedGame  或者  我也不太确定  Dan  我猜的


在 安卓  Java  系统里  加载和打开一个截屏


通过使用  Games.Snapshots.open method  这个语句就可轻松实现


在  iOS  系统里  你将会使用


openWithFileName, conflictPolicy, completionHandler method  这个语句


在C++系统里  你将会使用截屏


管理器的打开指令


这些执行代码之间的确有轻微的变化


但是你会注意到在所有这些情况里


你给截屏赋予了一个名称


在程序的结尾


截屏就会被打开


而且可以读写数据


通过调取一个二级指令


可以实现读取截图信息


这个指令指向截图本身  或者截图的元数据上


在安卓领域  这个指令是  readFully


在iOS系统  它是  readWithCompletionHandler


而在C++里   它是  read or readBlocking


而且  这是一个独立的指令


因为当我们就要加载截图数据到缓存里的时候


我们很可能没想过非得加载一个高达3M的游戏数据


除非我们必须这样做


而且在所有的情况下  你都将要得到


一个 字节数组  一些NSData  或者一个byte vector


然后你有必要将它们应用在你的游戏和程序里


现在我们可以说我们已经打开了你的截图


而且读取了一些数据并导入了我们的游戏中


现在玩家已经完成了一些游戏进度


而且想要保存他们的游戏


想在安卓系统里实现这个的话  你需要


把这个游戏的数据重新写入


你早前打开的那个相同的截图里


你不必再重新创建一个新的截图


你需要做的是创建一个截图元数据的


变更数据包


因此让我们忽略截图的其余部分


我们只需要关注这个新的数据包


元数据变更数据包基本上是


元数据的一个要素清单


比如一个描述信息  时间牌  或者封面图像


更新版本的截图里的这些信息与


上一版所呈现的有所不同


基本上  所保存的游戏API将会关注这一个变更数据包


并且在某种程度上覆写于你的旧的元数据之上


以建立新的元数据包


一旦你完成了这一步  你将命令安卓设备调取执行和关闭指令


并在这些设备上


使用新的数据以及元数据变更数据包


去更新旧的截图


在iOS系统及C++中  有一点小小的差别


你将会创建一个新的游戏数据包而不是覆写旧的


但是你也会仍然创建一个元数据变更数据包


那么这时候一切都建立完毕


你会使用目前这个截图元数据


并对其调用  commitMethod  命令


对于C++你需要采用类似的做法


在这两种情况下  你能够看到我们拥有了我们最新的


开启截图  我们的元数据变更数据包  以及我们的新数据


一旦你保存了所有这些信息


并执行了你的截图  那么就大功告成了


你将会想要再打开它一次


如果你想要对它写入更多的数据的话


很简单  是不是


好的  让我们看看某些


时髦的情况


如果有一个新玩家  或者某个以前从来没有


登陆过游戏服务器的人


他们试图打开一个根本不存在的保存游戏的文件  你将会怎么做


事实上  这不算是一个真正的问题


在安卓系统里  你赋给截图的语句里其中有一条打开命令


是  createIfNotFound Boolean


把这个值设置为  true  你就全都设置好了


你仅仅打开了一个没有任何数据的截图


在 iOS和 C++里  你甚至不需要那样做


它将会默认创建一个空的资料夹


这时你仅仅把这个空的资料夹当做任何一个其他的截图来对待


它仅仅是这样一个资料夹  它不含任何数据  而且所有元数据都设为


缺省值和/或 null  或者我猜在iOS系统里是nil


很简单地利用你的首次游戏设置更新这个截图  


和合理的元数据变更数据包


你可以很快就使得这个截图类似一个真正的截图


那么直到现在  我们已经谈论了


你是如何反复的加载和保存同一个游戏的文件


现在 让我们谈谈你如何管理多个保存的游戏文件


你会怎么做呢


开始的时候  你不必


硬编码你的截图名称


你需要指出


在运行时保存和加载哪一个截图


为了实现那样的功能  你将需要赋予用户


选择的能力 选择哪一个存档的游戏


以及创建一个游戏存档  等等


很幸运的说  管控这一切的用户界面


会由游戏服务实验室提供给你


如果你想要提供一个游戏存档的列表给用户


我们的用户界面可以给你想要的


现在这个用户界面有好几个设置供你选择


有的是安卓和C++里的参数


有的是C语言里的代理方法


这些设置将会让你能够定义有多少游戏存档


可以显示在这个用户界面里  是否给予用户


删除存档的权限  最重要的是


用户是否有创建新的存档的权限


现在如果我是一个用户的话  当我点击其中一个存在的存档


你的游戏里会触发一个回调  在那个回调里


你将能够找回这个截图的名字并开启游戏


现在你仅仅用这个名字就可以就像以前一样打开正确的截图


现在你可以尽情享受游戏的快乐


但是如果我是一个玩家  而且我想要创建一个新的游戏存档


我会点击  保存新游戏  按钮


你的APP会得到一个该按钮被点击的回调


这时  它取决于你通过请求打开一个


拥有全新名字的游戏存档去创建一个新的截图


那么你决定给它一个什么名字


这似乎取决于你


你可以使用时间戳  那个真的很不错


你可以使用附加在时间戳


上的随机数  我想这个会更加好


你可以搜索所有其他截图的名字


验证它们  然后为新的截图增加一个数字


那也同样有用


唯一的诀窍是这需要


与这个特定的玩家唯一对应


命名无需过于令人印象深刻


正如你刚刚所见  你只要


从我们实验室提供的用户界面得到文件名即可


因为它永远不会被我们的用户看到


用户也永远不会需要用名字作为参考


然而你给它命名了  一旦你需要一个


带有从未出现过的名字的截图的时候


你会得到一个空的截图以作为你的新游戏


你要记住这些流动


就像你在主机游戏开始前看到的一样


我现在在主界面  我想要启动游戏


游戏界面提示我是选择从一个先前存档的游戏继续玩


还是完全开始一个新的游戏


这个并非真的倾向于让用户更换


存档的游戏或是完全复制他们的进程或是任何其他类似的行为


我的意思是  假设你可能破解它的工作方式


但它会觉得有点笨重


好的  你已经明白了这一点


给自己一个鼓励因为你已经完成了初级课程


好了  别拍了别破坏我们良好的摄制环境


但是真正的考验来了


你马上要开始检查并解决截图冲突问题


对于这个问题  你需要观看我们的下一个视频


希望这个链接在你们观看这个视频的时候


会显示出来  如果没有  赶快回头查看一下


因为它一定会出现


好的感谢观看


请关注我的G+或者推特


在第二部分我会很快与大家再见


我们激动人心的结论








