## Google Cloud Messaging 

![video_screenshot](images/owhf42SZadk.jpg) 

** 视频发布时间**
 
> 2014年6月25日

** 视频介绍**

> Learn how to use GCM User Notifications feature to enable your app to deliver notifications to multiple devices belonging to the same user and how to handle synced dismissals.

** 视频推介语 **

>  暂无，待补充。

### 译者信息 

| 翻译 | 润稿 | 终审 | 原始链接 | 中文字幕 |  翻译流水号  |  加入字幕组  |
| ----|----|----|----|----|----|----|
| 田源 | 黄莘 | -- | [ Youtube ]( https://www.youtube.com/watch?v=owhf42SZadk ) | [ Youtube ](https://www.youtube.com/watch?v=4Zfqrydylhg) | 1504020524 | [ 加入 GDG 字幕组 ]( {{ book.host }}/join_translator ) |


### 解说词中文版：

大家好

我叫Subir  在Google主要负责云消息团队

今天  我们来聊聊Google Cloud Messaging（GCM）中的和与GCM相关

的一些酷炫的API

GCM提供了从服务器向设备高效便捷发送信息

的一系列底层API

我想感谢一下所有使用Google Cloud Messaging的开发者们

因为它确实通过降低电池寿命、无线电启动

和网络信号搜索对程序的影响

提升了生态系统的用户体验

我们先来看看一些使用GCM之前所需的API

要使用GCM，程序需要一个注册ID(Registration ID)

使用Registration ID向特定设备发送消息。

多播允许用户通过一个单一请求向最多1000个目标

发送消息

而且你可以为每个请求设置Time To Live

通知GCM处理过期消息

那么在2014年有什么新特性呢？

今天  我会介绍三个GCM提供的

主要特性--基于XMPP的云连接服务

上行消息，和用户通知

在2013年，我们将这些API开放给了小部分开发者

之后，我们向这些API添加了一些新特性

是他们运行更快速，更健壮

我们收到了大量的来自开发者对于这些API

的兴趣和反馈

这里我很高兴的通知大家

现在这些服务已经向所有开发者开放

下面我们聊聊GCM中关于XMPP的内容，

它也被称为云连接服务（Cloud Connection Server）

云连接服务  或者说CCS  

为GCM服务提供了

持续的  异步的  双向的连接

这是一个很强大的服务

它为你的服务器和你用户的UCM所连接的设备

提供了一个虚拟连接

这个连接可以用来发送和接收消息

这是如何连接CCS的方法

我用到了Python里的XMPP库来连接CCS

正如你看到的，地址是gcm.goobleapis.com而端口是5235

你只需连接到这个终端

并用你的API key进行认证就行。

下一步就是发送消息

这些信息中包含JSON数据

其中封装了目的地，应用数据，和一个消息ID

由于通过XMPP发送消息是异步的

消息ID就是用来唯一标识XMPP连接的

所以当CCS向你的服务器回发ACK的时候

它会使用消息ID来识别消息

所以这个消息ID不仅要是唯一的

而且要出现在请求中

我们来看看ACK或者NACK消息

是什么样的

消息类型会说明它是ACK还是NACK

而对于NACK来说  还会有错误代码

来描述遇到的问题

所以当要实现一个CCS连接的时候  这就是你需要知道的。

我们允许每个发送者使用最多发送100个连接

而每个连接最多能发出的消息数也是100

改进的错误处理机制能让你

更快定位出错的位置

这是一个控制消息的例子

它描述了一个即将关闭的连接

这条消息的意思是发送者不应该再向

这个连接发送消息

所有再发送到该连接的消息

都会收到一个NACK  其中带有错误代码

告知发送者这个链接即将关闭

我们还添加了其它类型的错误代码

比如和JSON解析相关的，等等

那么目前为止我们学习了当XMPP作为末端

GCM可以提供与你的服务器之前的

持续的，双向的连接

我们也看到了如何通过这个连接

向设备发送消息

下面  我们来看看极好的上行消息

API  它会帮你从应用程序里

向服务器发消息

我们已经做了很多工作

来使上行消息更快  更稳定

而且我很高兴的告诉大家现在该功能也向所有开发者开放了

那么我们来看一下

由于设备和GCM之间的连接已经存在了

它是低延迟发送  所以就不需要握手

如果设备离线了这些消息会在本地进行存储

并在有连接以后发送出去

我们使用在下行消息中

同样的可靠消息队列技术

所以如果和服务器断开了连接

我们会在重新建立连接之后发送一次消息

一旦收到来自你服务器的ACK  我们会删掉这些消息

要接收上行消息

你的服务器首先需要连接到CCS

这是例子展示了如何使用Google云消息API

发送消息。

将Project ID设置为目的地

之后我们会将消息发送到你的服务器

你可以发送并且在调用API的时候设置Time To Live

这就是ACK

重申一下  由于返回是异步的

MessageID是用来标识消息的

这儿有些在使用上行消息的时候的注意事项

待发消息不能超过100

如果你的服务器断开连接超过24小时

我们会删除你的消息

我们同样允许单一设备发送最大20条

未被接收确认的上行消息

所以接收确认是必须的

同时与下行消息类似

上行消息的最大负载容量是4k

这是一些GCM中我喜欢的API----发送状态反馈（Delivery Receipts）

当向设备发送消息时  开发者们的普遍需求是

能够获得消息的内部状态

来获知消息是否被成功发送

比如  你正在开发一个消息应用

而且当消息成功发送后会通知发送者

现在通过CCS  你可以实现该功能了。

我们正在添加这个新特性  叫做发送回复（Delivery Receipts）

这个例子告诉你如何向消息请求回复

在消息的JSON负载中，

你仅仅需要将Delivery Receipt Requested设置为True即可

这个值默认是设置为False的

这是一个回复消息

这个消息会有一个新的消息ID

来源会设置为gcm.google.apis.com  而类型会设置为"回复"

在返回数据中有四个域要添加

消息状态，原始消息ID，发送时间

最初消息的注册ID

目前，用户已经普遍拥有多种设备

所以会多次收到通知

这个功能会较少通知，使通知变得更加实用而不是惹人讨厌

幸亏GCM提供了一种简便的方式来通知多个设备

叫做用户通知，通过该功能

你可以同步用户通知，包括已经解除的通知

未来我会深入讲讲接触通知相关的东西

通过用户通知  你可以通过单一请求

向用户的所有终端发起通知

这是一个非常强大的API

它能简化你的通知

我会给你几个例子

你可以设置一个短的TTL，那么通知仅仅

发送给当前连接的设备

另一个例子是使用空闲延迟（Delay While Idle）选项

想象一下你的用户整天带着手机

而平板电脑留在家里

通过设置Delay While IDLE和TTL

你可以仅向正在使用的手机发通知

很实用，不是吗？

要向用户的所有设备发送消息

你需要一个Notification Key(通知键值)

应用服务器可以通过添加或者删除

Notification Key名称来获得键值

我们来看看如何获得Notification Key

这是一个获得键值和HTTP头部的末端

这个请求是使用你的项目API Key进行认证的

所以首先  我们要向Notification Key添加注册

你可以做一次Create

如果用户在其它设备上安装了该应用

你可以用一个Add

而最重要的域是Notification Key Name

对我们来说，它是一个唯一的标识

你可以通过该标识辨认用户

真正的用户名称是无关的

所以请使用哈希

对于用户来说必须是唯一的

这是一个例子，它展示了你如何

向用户的所有设备发送消息

唯一的不同是我们现在向注册ID发送一个Notification Key

而不是发送消息

现在让我们来假设一下用户在一个设备上操作通知

而我们希望能在所有设备上

解除通知

那么我们如何实现它呢？

通过上行消息，我们可以向Notification Key发送消息

而GCM会向其它与这个key相关的

注册设备发送消息

这样，你可以通知其它设备

解除通知，因为该通知在一台设备中已经被处理过了

此外，你也可以在单独上行消息中

发送"Get to a Project ID"消息到

你的应用服务器

这是一个例子

正如你看到的  上行消息中的这两个域

要设置为Notification Key

GCM会将该消息发送到

和这个Key相关的其他设备上

User Notification在HTTP和XMPP上都可以用

它可以支持每个Notification Key中最多20个设备

当然  请求中的key name对于用户来说必须是唯一的

在我们结束前  我建议大家看看

所有GCM API和服务的相关文档

和通常一样  就是这个链接

感谢观看

希望大家喜欢使用新的API和服务

并且从视频中有所收获

