## Isolation for Android App Developers 

![video_screenshot](images/Ive8WaeldWA.jpg)  

** 视频发布时间**
 
> 2014年6月25日

** 视频介绍**

> The Android platform provides a ton of great security tools, but some of those don't get the attention they deserve. This talk aims to close that gap by highlighting some of the best and least-known techniques for the development of both Android apps and the Android platform itself.

** 视频推介语 **

>  暂无，待补充。

### 译者信息 

| 翻译 | 润稿 | 终审 | 原始链接 | 中文字幕 |  翻译流水号  |  加入字幕组  |
| ----|----|----|----|----|----|----|
| Martin  | 黄莘 | -- | [ Youtube ]( https://www.youtube.com/watch?v=Ive8WaeldWA ) | [ Youtube ](https://www.youtube.com/watch?v=pEt6JoJhMlA) | 1504020498 | [ 加入 GDG 字幕组 ]( {{ book.host }}/join_translator ) |


### 解说词中文版：

Android App沙盒做了一件很伟大的工作

那就是默认保持app之间相对独立

但是当提供的隔离等级

和应用模型不和呢

Hi  我是Geremy Condra  在这个视频中

我们将讨论你该如何用Android平台来

支持不同的隔离模型

使你的应用更加强大和安全

你看到的是一些Android提供的

最重要的隔离层的

宽松模型  SELinux保护

系统组件中独立的应用

你可以看到Linux用户  一个分离的UID

用来保持应用分离开来

你还可以看到应用组件之间进程等级的分离

所以  让我们来讨论进程中的分离

当Zygote产出一个应用时

这些应用通常都会有自己的进程

这防止别的应用来修改这个应用的内存

在另一方面把一个应用和崩溃隔离开来

所以事实就是当你的应用和其他一些糟糕的应用在

同一个手机上的时候这并不影响你的应用的体验

它也让应用和系统组件隔离

同时系统组件之间也是隔离的

稍微放大一点  我们可以看到

这两个app虽然不共享一个进程

但却能用一些方式来交流  例如binder

或者是向系统发送intent  或者通过旧的机制像Pipe或者是Socket

不共享一个进程的原因是

进程的分离并不是很严格

当你仍然可以跨过这些边界来交流的时候

你就可以用小的开销来获得好的隔离效果

当然了  当我们在这里讨论隔离模型的时候

我们真正的意思是  当一个进程死亡或是

被破坏  其他的进程依然可以正确运行

所以  这就是默认的模型

这对种类繁多的应用来说非常好

但是当基础模型不能提供你需要的隔离模型

的时候会发生什么

当你想从另一部分隔离你应用的一部分的时候

你会怎么做  比如当你想从crashy service

或者是一个network-aware组件中隔离持有秘钥或者是

其他敏感数据的应用的时候你会怎么做

幸运的是  Android很懂你

Activities和服务都支持Android进程属性

这将允许你指定你想把你的代码

运行在什么进程里 然后它可以为该组件

生出新的进程  如果进程不存在的话

在这里例子里  我们有一个服务

如果它崩溃了而我们不想要关闭其他的应用

通过指定它应该在一个叫做colon crashy的进程中运行

我们确保Android会把这个服务运行

在一个专门为此创建新进程中

一旦你完成这些  这个进程集合

就会更像这样

因为colon crashy和应用处理器是分开的

crashy可以关闭然而并不需要关闭其他的应用

你可以用它来更好地限制你的进程间通信(Inter-Process Communication)的端点

在这个模型中  colon crashy并不需要

其他组件来间接向进程间通信端点交流

为什么我们需要其他的隔离层

为什么不直接用进程来做所有事情

我们不用进程分离做所有事是因为

它没有一套不同的

永久的凭证

所以其他进程也许不能

修改你的内存  如果它拥有一样的UID

但是它仍拥有同样的权限

它有读和写同样的文件的权利  等等

结论就是  除了被进程边界

分开  Android应用程序

通常也作为他们自己的用户运行

这构成了App沙盒的基础

以及应用程序主目录之间的分离

如此  Android提供了一个kernel-enforced guarantee

那就是应用程序的数据只能

被自己修改  除非这个应用允许其他程序来修改

这无疑使应用程序更加灵活和可控制

这个规则有两个例外  那就是每个应用都有自己的

共享UID和隔离进程

让我们先讨论一下共享UID

在这个图表中  应用B和C被标记了共享UID

应用A则没有

应用程序被标记共享UID并使用

相同的签名秘钥就能做到大部分另外应用程序能做到的事

所以从安全的角度来说  标记两个应用程序为共享UID

意味着它们实质上可以被当成一个应用来看待

这有时对分离应用程序很有用

或是用有趣的方式提供访问资源的权限

但是在安全的角度上  我们更经常遇到相反的问题

如果我想打破一个应用并把它分成几个安全环境  

我该怎么做呢

这就是隔离进程起作用的地方

为了知道它为什么有用  让我们返回

到crashy service的这个例子中

尤其是对于原生代码  当你只是想从崩溃的可能性中隔离

你自己的时候  你的代码可能会毫无迹象地崩溃

如果你的代码真的很可疑  像某些类型的渲染器

或媒体编解码器  你或许不想

对那些代码做太多工作

事实上  你可能想要把它运行在一个完全分离的

进程用户中  实质上  就像它自己的分离的应用

而这就是隔离进程所做的事

最终的结果看起来是这样的

应用A分离成两个组件

每个都是在不同的用户和进程下

意思就是从这个应用A中被隔离的

那部分就像别的应用一样

所以  什么时候你应该使用进程  什么时候你应该

使用隔离进程

当隔离的代码是纯Java

当它不包含一个解释器或类似的东西

或当它需要以你的名义来与其他进程交互的时候就用进程

当隔离的代码是原生代码

当它进行复杂的操作  像渲染或编码

当它包含一个解释器或JIT

当它不需要以用户的名义来

运行的时候就用隔离进程

这就是我要说的为Android app开发者设计的隔离模型

一定要看看这个系列的其他视频

最后感谢观看

