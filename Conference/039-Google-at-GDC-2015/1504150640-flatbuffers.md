
## Lightning Talk: FlatBuffers

![video_screenshot](images/olmL1fUnQAQ.jpg)

** 视频发布时间**
 
> 2015年3月12日

** 视频介绍**

> Watch the complete GDC '15 playlist at: http://goo.gl/whR0PLSerialization is cool! And serialization sucks. How can you seralize the massive amounts of data that ships with your game without killing your performance or memory? We don't want to give away the answer, but it's kinda in the title...

** 视频推介语 **

>  暂无，待补充。


### 译者信息

| 翻译 | 润稿 | 终审 | 原始链接 | 中文字幕 |  翻译流水号  |  加入字幕组  |
| -- | -- | -- | -- | -- |  -- | -- | -- |
| 葛伟 | 素年待锦 | —— | [ Youtube ]( https://www.youtube.com/watch?v=olmL1fUnQAQ )  |  [ Youtube ]( https://www.youtube.com/watch?v=m2D2oLHNeK8&index=51&list=PLvivLNHqjoowK2IZ9j_NYIucUrGgdiDrT ) | 1504150640 | [ 加入 GDG 字幕组 ]( {{ book.host }}/join_translator )  |



### 解说词中文版：

大家好

我是Wouter van Oortmerssen

是谷歌Fun Propulsion Labs团队的一员

我们的工作是制作各类库和工具

帮助安卓或其他平台的开发者优化他们的游戏开发等

其中一个是FlatBuffers

FlatBuffers是一个工具库

它可以让你的游戏载入更快并且使用更少的内存

想想  你的游戏需要多少时间

载入数据呢

载入数据需要很多时间  因为通常游戏

数据储存在不同的硬盘  而不是在内存中

相对来说这会节省很多空间

而且它可以被储存为文本格式以便人们进行编辑

这两种模式之间的转化就是

我们所说的序列化

现在序列化变得很棒  因为数据和内存可以专注于

他们各自的特长  这意味着缓冲更快更容易

同时数据在硬盘上

也各有优点  易于压缩

独立于计算机  可以发送  向后兼容

但是序列化也有其弊端  因为所有的压缩

及解压都要花时间

这需要辅助存储器  因为我们

需要把这些序列化的数据解压到对象中

这就使得格式化变得易错

所以如你所知  在个别游戏中  需要很多内存

我们有办法修复这个问题吗

好吧  这些问题都来源于我们假设

内存和硬盘特性是天生相互矛盾

在储存数据时

但是如果我们换别的方法呢

现在  你就需要FlatBuffers

FlatBuffers实际是一个可移动的赋值格式

它可以让你在硬盘上储存数据的同时

在内存上储存同样的数据  这也就意味着

你不需要转换就可以将其中一个移动到另一个

这个在硬盘上工作的很好  因为它对一下几方面有固定的规则

比如硬盘格式   校准 和一个附加的平台

这解决了向前  向后兼容性的问题

你可以很容易的添加  移动文件

它在内存上也工作的很好

通过offset我们可以完成任何事  所以它的效率超级高

有一点很棒的就是它工作时有只读权限

并且只需要很小的的缓冲区

相对于独立分配到对象中来说

在这方面  我可以说出很多理由

让你只想用FlatBuffers

所以你该怎么做呢

首先  你要写一个schema

然后将你的schema放入schema编译器中

我们将会以你最喜欢语言生成的代码

假设你最喜欢的语言是这四种中的一种

将生成的代码加载到你的游戏中

读取  写入FlatBuffer数据

schema文件最重要一点的就是高效

没有错误检查之前你也可以访问你的数据

你可以在不重生成你所有数据的情况下修改schemas文件

举个例子  你要升级你的游戏

但你又需要以前储存的游戏都还在运行

你该怎么停止FlatBuffer

人们通常都会怀疑该怎么做

为了向前  向后的兼容性

我们有个可以添加或者移除文件的表格

这个间接的方式称为虚拟表格

此外我们还有structs

如果你希望效率最大化

不要支持格式化操作

当然  这是最快的储存数据方式

最后  我们有enums  unions  及一些其他很酷的东西

让我们来看看听到的这些该怎么实现

这是一个内存中对象

它以一个虚拟表格中的offset开始

它是含有实际的文件的offset

现在  这些虚拟表格在相似的对象之间共享

所以实际上他们并不会占用很多空间

接下来就是实际的文件

依次进入  包括 structs等

如果你需要引入一个大数据文件

这需要通过一个间接的offset

我们来看看在c++代码中你该怎么用这个

首先你要定位到你的根对象

然后用文件存储器真实的看看这个些数据

这为你隐藏了所有的offset检查

所以很方便

用FlatBuffer建一个组分帮助者分类

之后你调用这个建立函数时

它将会在缓冲区为你建立对象

我知道这听起来不可能很快  但它究竟有多快呢

我们来将它和其他主流的序列化对比一下

结果

当然  你需要一个参照标准

我相信你最终会发现一些有趣的事

所以如果你打算测试FlatBuffer

你会发现他快1000倍

相比其他结果来说

这是因为我们实际上没有进行解析

或者分配任何事

写一个FlatBuffer也会快100倍

这也是很好的

实际上我们没有分配任何对象

这样我们读取数据时就会很方便

最好  代码也很少

这些是为了产生代码和程序库代码

你也许会说你不关心这些

我仍然打算用文本  因为我认为这很容易做到

你知道吗

FlatBuffers也支持JSON格式输出

这意味这你可以转换到二进制格式

包括飞行在内的所以游戏中的过程

都在我们命令行中

以上就是我介绍的所以内容

在GDC可以联系我们或者我

谢谢

背景音乐




